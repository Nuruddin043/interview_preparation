一个各公司都喜欢拿来做面试笔试题的经典动态规划问题，互联网上也有很多文章对该问题进行讨论，但是我觉得对该问题的最关键的地方，这些讨论似乎都解释的不很清楚，让人心中不快，所以自己想彻底的搞一搞这个问题，希望能够将这个问题的细节之处都能够说清楚。

对于动态规划问题，往往存在递推解决方法，这个问题也不例外。要求长度为i的序列的Ai{a1,a2,……,ai}最长递增子序列，需要先求出序列Ai-1{a1,a2,……,ai-1}中以各元素(a1,a2,……,ai-1)作为最大元素的最长递增序列，然后把所有这些递增序列与ai比较，如果某个长度为m序列的末尾元素aj(j<i)比ai要小，则将元素ai加入这个递增子序列，得到一个新的长度为m+1的新序列，否则其长度不变，将处理后的所有i个序列的长度进行比较，其中最长的序列就是所求的最长递增子序列。举例说明，对于序列A{35, 36, 39, 3, 15, 27, 6, 42}当处理到第九个元素(27)时，以35， 36， 39， 3， 15， 27， 6为最末元素的最长递增序列分别为
    35
    35，36
    35，36，39
    3
    3，15
    3，15，27
    3，6
当新加入第10个元素42时，这些序列变为
    35，42
    35，36，42
    35，36，39，42，
    3，42
    3，15，42
    3，15，27，42
    3，6，42
这其中最长的递增序列为(35，36，39，42)和(3，15，27，42)，所以序列A的最长递增子序列的长度为4，同时在A中长度为4的递增子序列不止一个。

该算法的思想十分简单，如果要得出Ai序列的最长递增子序列，就需要计算出Ai-1的所有元素作为最大元素的最长递增序列，依次递推Ai-2，Ai-3，……，将此过程倒过来，即可得到递推算法，依次推出A1，A2，……，直到推出Ai为止，

代码如下
[cpp] view plaincopy
unsigned int LISS(const int array[], size_t length, int result[])  
{  
    unsigned int i, j, k, max;  
  
    //变长数组参数，C99新特性，用于记录当前各元素作为最大元素的最长递增序列长度  
    unsigned int liss[length];  
  
    //前驱元素数组，记录当前以该元素作为最大元素的递增序列中该元素的前驱节点，用于打印序列用  
    unsigned int pre[length];  
  
    for(i = 0; i < length; ++i)  
    {  
        liss[i] = 1;  
        pre[i] = i;  
    }  
  
    for(i = 1, max = 1, k = 0; i < length; ++i)  
    {  
        //找到以array[i]为最末元素的最长递增子序列  
        for(j = 0; j < i; ++j)  
        {  
            //如果要求非递减子序列只需将array[j] < array[i]改成<=，  
            //如果要求递减子序列只需改为>  
            if(array[j] < array[i] && liss[j] + 1> liss[i])  
            {  
                liss[i] = liss[j] + 1;  
                pre[i] = j;  
  
                //得到当前最长递增子序列的长度，以及该子序列的最末元素的位置  
                if(max < liss[i])  
                {  
                    max = liss[i];  
                    k = i;  
                }  
            }  
        }  
    }  
  
    //输出序列  
    i = max - 1;  
  
    while(pre[k] != k)  
    {  
        result[i--] = array[k];  
        k = pre[k];  
    }  
  
    result[i] = array[k];  
  
    return max;  
}  
该函数计算出长度为length的array的最长递增子序列的长度，作为返回值返回，实际序列保存在result数组中，该函数中使用到了C99变长数组参数特性（这个特性比较赞），不支持C99的同学们可以用malloc来申请函数里面的两个数组变量。函数的时间复杂度为O(nn)，下面我们来介绍可以将时间复杂度降为O(nlogn)改进算法。
在基本算法中，我们发现，当需要计算前i个元素的最长递增子序列时，前i-1个元素作为最大元素的各递增序列，无论是长度，还是最大元素值，都毫无规律可循，所以开始计算前i个元素的时候只能遍历前i-1个元素，来找到满足条件的j值，使得aj < ai，且在所有满足条件的j中，以aj作为最大元素的递增子序列最长。有没有更高效的方法，找到这样的元素aj呢，实际是有的，但是需要用到一个新概念。在之前我举的序列例子中，我们会发现，当计算到第10个元素时，前9个元素所形成最长子序列分别为

    35
    35，36
    35，36，39
    3
    3，15
    3，15，27
    3，6

这其中长度为3的子序列有两个，长度为2的子序列有3个，长度为1的子序列2个，所以一个序列，长度为n的递增子序列可能不止一个，但是所有长度为n的子序列中，有一个子序列是比较特殊的，那就是最大元素最小的递增子序列（挺拗口的概念），在上述例子中，序列(3)，(3,6)，(3，5，27)就满足这样的性质，他们分别是长度为1，2，3的递增子序列中最大元素最小的（截止至处理第10个元素之前），随着元素的不断加入，满足条件的子序列会不断变化。如果将这些子序列按照长度由短到长排列，将他们的最大元素放在一起，形成新序列B{b1,b2,……bj}，则序列B满足b1 < b2 < …… <bj。这个关系比较容易说明，假设bxy表示序列A中长度为x的递增序列中的第y个元素，显然，如果在序列B中存在元素bmm > bnn，且m < n则说明子序列Bn的最大元素小于Bm的最大元素，因为序列是严格递增的，所以在递增序列Bn中存在元素bnm < bnn，且从bn0到bnm形成了一个新的长度为m的递增序列，因为bmm > bnn，所以bmm > bnm，这就说明在序列B中还存在一个长度为m，最大元素为bnm < bmm的递增子序列，这与序列的定义，bmm是所有长度为m的递增序列中第m个元素最小的序列不符，所以序列B中的各元素严格递增。发现了如此的一个严格递增的序列，这让我们柳暗花明，可以利用此序列的严格递增性，利用二分查找，找到最大元素刚好小于aj的元素bk，将aj加入这个序列尾部，形成长度为k+1但是最大元素又小于bk+1的新序列，取代之前的bk+1，如果aj比Bn中的所有元素都要大，说明发现了以aj为最大元素，长度为n+1的递增序列，将aj做Bn+1的第n+1个元素。从b1依次递推，就可以在O(nlogn)的时间内找出序列A的最长递增子序列。

理论说明比较枯燥，来看一个例子，以序列{6，7，8，9，10，1，2，3，4，5，6}来说明改进算法的步骤：
程序开始时，最长递增序列长度为1（每个元素都是一个长度为1的递增序列），当处理第2个元素时发现7比最长递增序列6的最大元素还要大，所以将6，7结合生成长度为2的递增序列，说明已经发现了长度为2的递增序列，依次处理，到第5个元素(10)，这一过程中B数组的变化过程是

    6
    6，7
    6，7，8
    6，7，8，9
    6，7，8，9，10
开始处理第6个元素是1，查找比1大的最小元素，发现是长度为1的子序列的最大元素6，说明1是最大元素更小的长度为1的递增序列，用1替换6，形成新数组1，7，8，9，10。然后查找比第7个元素(2)大的最小元素，发现7，说明存在长度为2的序列，其末元素2，比7更小，用2替换7，依次执行，直到所有元素处理完毕，生成新的数组1，2，3，4，5，最后将6加入B数组，形成长度为6的最长递增子序列.

这一过程中，B数组的变化过程是

    1，7，8，9，10
    1，2，8，9，10
    1，2，3，9，10
    1，2，3，4，10
    1，2，3，4，5
    1，2，3，4，5，6
当处理第10个元素(5)时，传统算法需要查看9个元素(6,7,8,9,10,1,2,3,4)，而改进算法只需要用二分查找数组B中的两个元素(3, 4)，可见改进算法还是很阴霸的。

下面是该算法的实现：
[cpp] view plaincopy
unsigned int LISSEx(const int array[], size_t length, int result[])  
{  
    unsigned int i, j, k, l, max;  
  
    //栈数组参数，C99新特性，这里的liss数组与上一个函数意义不同，liss[i]记录长度为i + 1  
    //递增子序列中最大值最小的子序列的最后一个元素（最大元素）在array中的位置  
    unsigned int liss[length];  
  
    //前驱元素数组，用于打印序列  
    unsigned int pre[length];  
  
    liss[0] = 0;  
  
    for(i = 0; i < length; ++i)  
    {  
        pre[i] = i;  
    }  
  
    for(i = 1, max = 1; i < length; ++i)  
    {  
        //找到这样的j使得在满足array[liss[j]] > array[i]条件的所有j中，j最小  
        j = 0, k = max - 1;  
  
        while(k - j > 1)  
        {  
            l = (j + k) / 2;  
  
            if(array[liss[l]] < array[i])  
            {  
                j = l;  
            }  
            else  
            {  
                k = l;  
            }  
        }  
  
        if(array[liss[j]] < array[i])  
        {  
            j = k;  
        }  
  
        //array[liss[0]]的值也比array[i]大的情况  
        if(j == 0)  
        {  
            //此处必须加等号，防止array中存在多个相等的最小值时，将最小值填充到liss[1]位置  
            if(array[liss[0]] >= array[i])  
            {  
                liss[0] = i;  
                continue;  
            }  
        }  
  
                //array[liss[max -1]]的值比array[i]小的情况  
                if(j == max - 1)  
        {  
            if(array[liss[j]] < array[i])  
            {  
                pre[i] = liss[j];  
                liss[max++] = i;  
                continue;  
            }  
        }  
  
        pre[i] = liss[j - 1];  
        liss[j] = i;  
    }  
  
    //输出递增子序列  
    i = max - 1;  
    k = liss[max - 1];  
  
    while(pre[k] != k)  
    {  
        result[i--] = array[k];  
        k = pre[k];  
    }  
  
    result[i] = array[k];  
  
    return max;  
}  
这个算法的思想可以算得上巧妙，在时间复杂度上提升明显，但是同时在实现时也比通俗算法多了好些坑，这里说明一下：
算法中为了获得实际的序列，数组B中保存的不是长度为j的递增序列的最大元素的最小值，而是该值在输入数组A中的位置，如果只想求出最长递增子序列的长度，则B数组可以直接保存满足条件元素的值
二分查找的结果，我们的目的是找到这样的一个j，使满足A[B[j]] > A[i]的所有j中，j取得最小值，但是在二分查找的时候可能会发生两种特殊情况，B数组的所有元素都不小于A[i]，B数组的所有元素都比A[i]小，对于这两中情况需要专门处理
对于B中所有元素都不小于A[i]的情况，要将A[i]更新到B[0]的位置
对于B中所有元素都小于A[i]的情况，要将更新到B[max]的位置，同时将max值增加1，说明找到了比当前最长的递增序列更长的结果
对于其他情况，在更新新节点的前驱节点时，要注意，当前元素的前驱节点是B[j-1]，而不是pre[B[j]]，这点要格外留意，后者看似有道理，但实际上在之前的更新中可能已经被变更过。
性能比较：长度为5000的随机数组，在我的机器上，改进算法的速度提升将近200倍，可见算法改进在程序性能表现中的重要性。不过传统算法也并非毫无价值，

首先，传统算法可以用来验证改进算法的正确性。二分搜索中的不确定性还是相当让人头痛的。其次，如果要求最长非递减子序列，最长递减子序列等等，传统算法改起来非常的直观（已经注释说明），而改进算法，最起码我没有一眼看出来如何一下就能改好。

目前我搜到的网上的有关此改进算法，在二分搜索满足条件的节点时，聊聊几笔，就完成了功能，但是我按照那种写法无一例外都遇到了某种类型的序列无法处理的情况，不知是否是我在理解算法方面出现偏差。

后继，研究完这个问题之后产生了两个遗留问题，暂时没有答案，和大家分享一下
对于一个序列A，最长递增子序列可能不止一个，传统算法找到的是所有递增子序列中，最大值下标最小（最早出现）的递增子序列，而改进算法找到的是最大值最小的递增子序列，那么改进算法所找到的递增子序列，是不是所有最长递增子序列中各元素合最小的一个呢，我感觉很可能是，但是还没想出怎么证明。
对于元素互不相同的随机数序列A，他的最长递增子序列的数学期望是多少呢？